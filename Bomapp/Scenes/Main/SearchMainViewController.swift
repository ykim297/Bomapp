//
//  SearchMainViewController.swift
//  Bomapp
//
//  Created by Yong Seok Kim on 2020/07/04.
//  Copyright (c) 2020 Yong Seok Kim. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RxSwift
import RxCocoa

protocol SearchMainDisplayLogic: class {
    func display(response: SearchMain.Repository.Response)
    func displayUserList(response: SearchMain.User.Response)
    func displayError()
}

enum Type: Int {
    case repository = 0
    case user = 1
}

class SearchMainViewController: BaseViewController, SearchMainDisplayLogic {
    
    var interactor: SearchMainBusinessLogic?
    var router: (NSObjectProtocol & SearchMainRoutingLogic & SearchMainDataPassing)?

    @IBOutlet weak var tableView: UITableView!
    
    let disposeBag = DisposeBag()
    let recent: BehaviorRelay<[String]> = BehaviorRelay(value: [])
    var searchController: UISearchController?
    let resultTableViewController: ResultTableViewController = ResultTableViewController()    
    var recentWords: [String]?
    var sort: String = "stars+updated"
    var order: String = "desc"
    var currentType: Type = .repository
    var repositoryModel: SearchMain.Repository.ViewModel?
    var userModel: SearchMain.User.ViewModel?
    var isConnecting: Bool = false
    var currentWord: String = ""

    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = SearchMainInteractor()
        let presenter = SearchMainPresenter()
        let router = SearchMainRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
        
    override func viewDidLoad() {
        super.viewDidLoad()
        self.setComponents()
        self.setTableViewCell()
                
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.navigationController?.navigationBar.prefersLargeTitles = true
        self.navigationItem.largeTitleDisplayMode = .always
        navigationItem.hidesSearchBarWhenScrolling = false
    }

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        navigationItem.hidesSearchBarWhenScrolling = true
        self.tableView.contentInsetAdjustmentBehavior = .never

    }
    
    // MARK: Do request
    func requestData(word: String) {
        self.isConnecting = true
        if self.currentType == .repository  {
            let request = SearchMain.Repository.Request(q: word,
                                                        sort: self.sort,
                                                        order: self.order,
                                                        page: self.repositoryModel != nil ? self.repositoryModel!.page + 1 : 1)

            interactor?.getSearchList(request: request)
        } else {
            let request = SearchMain.User.Request(q: word,
                                                  sort: "followers",
                                                  order: self.order,
                                                  page: self.userModel != nil ? self.userModel!.page + 1 : 1)
            interactor?.getSearchUSerList(request: request)
        }
    }

    func display(response: SearchMain.Repository.Response) {
        self.resultTableViewController.isShowResult = true
        if let viewModel = self.repositoryModel {
            let morePage: Bool = response.items.count > 0 ? false : true
            let lists: [SearchResultModel] = viewModel.lists + response.items
            self.repositoryModel = SearchMain.Repository.ViewModel(lastPage: morePage, page: viewModel.page + 1, lists: lists)
        } else {
            let morePage: Bool = response.items.count > 0 ? false : true
            self.repositoryModel = SearchMain.Repository.ViewModel(lastPage: morePage, page: 1, lists: response.items)
        }
        self.resultTableViewController.searchResultList = self.repositoryModel?.lists ?? []
        self.resultTableViewController.type = .repository
        DispatchQueue.main.async {
            self.resultTableViewController.tableView.reloadData()
            self.resultTableViewController.tableView.scrollToRow(at: IndexPath(row: 0, section: 0), at: .top, animated: false)
            self.isConnecting = false
        }
    }
    
    func displayUserList(response: SearchMain.User.Response) {
        self.resultTableViewController.isShowResult = true
        if let viewModel = self.userModel {
            let morePage: Bool = response.items.count > 0 ? false : true
            let lists: [OwnerModel] = viewModel.lists + response.items
            self.userModel = SearchMain.User.ViewModel(lastPage: morePage, page: viewModel.page + 1, lists: lists)
        } else {
            let morePage: Bool = response.items.count > 0 ? false : true
            self.userModel = SearchMain.User.ViewModel(lastPage: morePage, page: 1, lists: response.items)
        }
        self.resultTableViewController.userList = self.userModel?.lists ?? []
        self.resultTableViewController.type = .user
        DispatchQueue.main.async {            
            self.resultTableViewController.tableView.reloadData()
            self.resultTableViewController.tableView.scrollToRow(at: IndexPath(row: 0, section: 0), at: .top, animated: false)
            self.isConnecting = false
        }
    }
    
    func displayError() {
        alert("Server Error", message: "Server Error")
        self.resultTableViewController.tableView.reloadData()
    }    
    
}

// Draw
extension SearchMainViewController {
    private func setComponents() {
        searchController = UISearchController(searchResultsController: resultTableViewController)
        searchController?.searchResultsUpdater = resultTableViewController
        searchController?.searchBar.delegate = resultTableViewController
        searchController?.obscuresBackgroundDuringPresentation = false
        searchController?.searchBar.placeholder = "Search"
        searchController?.searchBar.scopeButtonTitles = ["Repository", "User"]
        
        searchController?
            .searchBar.rx
            .cancelButtonClicked
        .subscribe(onNext: { () in
            self.tableView.reloadData()
        })
        .disposed(by: disposeBag)

        self.title = "검색"
        navigationItem.searchController = searchController
        searchController?.searchBar.backgroundColor = .white
        definesPresentationContext = true
                
                
        self.tableView.rx.setDelegate(self).disposed(by: disposeBag)
        let singleImageContent = UINib(nibName: "RecentWordTableViewCell", bundle: nil)
        self.tableView.register(singleImageContent, forCellReuseIdentifier: "RecentWordTableViewCell")
        self.recent.accept(AppManager.shared.getRecentSearchWordList())
    }
    
    
}

// RxTableView
extension SearchMainViewController {
    private func setTableViewCell() {
        self.setTableViewDataSource()
        self.setTableViewSelection()
        self.setResultTableViewSelection()
    }
    
    private func setTableViewDataSource() {
        recent.asObservable()
            .bind(to: tableView.rx.items) { (tableView, row, element) in
                let list = AppManager.shared.getRecentSearchWordList()
                let indexPath = IndexPath(item: row, section: 0)
                if let cell = tableView.dequeueReusableCell(withIdentifier: "RecentWordTableViewCell", for:indexPath) as? RecentWordTableViewCell {
                    cell.recentLabel.text = list[indexPath.row]
                    cell.selectionStyle = .none
                    return cell
                }
                return UITableViewCell()
        }
        .disposed(by: disposeBag)
    }
    
    
    private func setTableViewSelection() {
        self.tableView.rx.itemSelected
            .subscribe(onNext: { [weak self] indexPath in
                guard let self = self else { return }
                let list = AppManager.shared.getRecentSearchWordList()
                self.searchController?.isActive = true
                self.searchController?.searchBar.text = list[indexPath.row]
                self.selectedSearchButton()
            }).disposed(by: self.disposeBag)
    }
    
    private func setResultTableViewSelection() {
        resultTableViewController.tableView.rx.itemSelected
        .subscribe(onNext: { [weak self] indexPath in
            guard let self = self else { return }
            let isResultShow = self.resultTableViewController.isShowResult
            if !isResultShow {
                let list = self.resultTableViewController.filteredWords
                AppManager.shared.addRecentSearchWord(text: list[indexPath.row])
                self.searchController?.searchBar.text = list[indexPath.row]
                self.selectedSearchButton()
            }
        }).disposed(by: self.disposeBag)
        
        resultTableViewController.tableView.rx
            .willDisplayCell
            .subscribe(onNext: { cell, indexPath in
                guard let word = self.searchController?.searchBar.text else {
                    return
                }
                if word != self.currentWord { return }

                if self.currentType == .repository {
                    guard let model = self.repositoryModel else {
                        return
                    }
                    let loadIndex =  model.lists.count - 5
                    if indexPath.row > loadIndex && !model.lastPage && self.isConnecting == false {
                        self.requestData(word: word)
                    }
                } else {
                    guard let model =  self.userModel else {
                        return
                    }
                    let loadIndex =  model.lists.count - 5
                    if indexPath.row > loadIndex && !model.lastPage && self.isConnecting == false {
                        self.requestData(word: word)
                    }
                }
            }).disposed(by: self.disposeBag)
        
        searchController?.searchBar
            .rx.searchButtonClicked
            .subscribe(onNext: { [weak self] _ in
            guard let self = self else { return }
                self.selectedSearchButton()                
        }).disposed(by: self.disposeBag)
        
        
        searchController?.searchBar
            .rx.selectedScopeButtonIndex
            .subscribe(onNext: { [weak self] _ in
            guard let self = self else { return }
                if self.currentWord == "" { return }
                let type: Int = self.searchController?.searchBar.selectedScopeButtonIndex ?? 0
                self.currentType = Type(rawValue: type)!
                
                if self.currentType == .repository && self.resultTableViewController.searchResultList.count != 0 {
                    DispatchQueue.main.async {
                        self.resultTableViewController.isShowResult = true
                        self.resultTableViewController.type = .repository
                        self.resultTableViewController.tableView.reloadData()
                    }
                    return
                }
                if self.currentType == .user && self.resultTableViewController.userList.count != 0 {
                    DispatchQueue.main.async {
                        self.resultTableViewController.isShowResult = true
                        self.resultTableViewController.type = .user
                        self.resultTableViewController.tableView.reloadData()
                    }
                    return
                }
                self.requestData(word: self.currentWord)
        }).disposed(by: self.disposeBag)
    }
    
    func selectedSearchButton() {
        guard let word = self.searchController?.searchBar.text else {
            return
        }
        
        AppManager.shared.addRecentSearchWord(text: word)
        self.recent.accept(AppManager.shared.getRecentSearchWordList())
        self.currentWord = word
        self.tableView.reloadData()

        self.repositoryModel = nil
        self.userModel = nil
        
        let type: Int = searchController?.searchBar.selectedScopeButtonIndex ?? 0
        self.currentType = Type(rawValue: type)!
        self.requestData(word: word)
    }
}


extension SearchMainViewController: UITableViewDelegate {
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        let list = AppManager.shared.getRecentSearchWordList()
        return list.count        
    }
                
    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
        return 40
    }
    
    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
        let view: UIView = UIView(frame: CGRect(x: 0.0, y: 0.0, width: UIScreen.width, height: 40.0))
        let title: UILabel = UILabel(frame: CGRect(x: 12.0, y: 5.0, width: 150.0, height: 30.0))
        title.backgroundColor = .clear
        title.textColor = .black
        title.font = .boldSystemFont(ofSize: 22.0)
        title.text = "최근 검색어"
        title.lineBreakMode = .byTruncatingTail
        view.addSubview(title)
        return view

    }
}
